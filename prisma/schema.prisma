generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                  String             @id @default(cuid())
  email               String             @unique
  name                String?
  company             String?
  created_at          DateTime           @default(now())
  updated_at          DateTime           @updatedAt
  default_currency    String             @default("GBP")
  industry_focus      String?
  location            String?
  phone               String?
  subscription_tier   String             @default("free")
  timezone            String             @default("Europe/London")
  reset_token         String?
  reset_token_expires DateTime?
  password            String?
  alerts              Alert[]
  analyses            Analysis[]
  seasonal_strategies SeasonalStrategy[]
  shopify_stores      ShopifyStore[]
  sku_histories       SKUHistory[]
  skus                SKU[]
  user_settings       UserSettings?

  @@map("users")
}

model UserSettings {
  id                     String  @id @default(cuid())
  user_id                String  @unique
  default_analysis_depth String  @default("standard")
  alert_frequency        String  @default("immediate")
  competitive_monitoring Boolean @default(true)
  email_alerts           Boolean @default(true)
  stock_alert_threshold  Int     @default(2)
  price_change_threshold Float   @default(10.0)
  user                   User    @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@map("user_settings")
}

model SKU {
  id                String                @id @default(cuid())
  sku_code          String
  user_id           String
  product_name      String?
  category          String
  subcategory       String?
  brand             String?
  price             Float
  cost_price        Float?
  weekly_sales      Float                 @default(0)
  inventory_level   Int                   @default(0)
  abv               Float?
  volume_ml         Int?
  container_type    String?
  vintage_year      Int?
  origin_country    String?
  origin_region     String?
  organic           Boolean               @default(false)
  gluten_free       Boolean               @default(false)
  craft             Boolean               @default(false)
  limited_edition   Boolean               @default(false)
  shelf_life_days   Int?
  storage_temp      String?
  distributor       String?
  vendor_code       String?
  barcode           String?
  supplier_sku      String?
  minimum_order_qty Int?
  lead_time_days    Int?
  last_sold_date    DateTime?
  last_ordered_date DateTime?
  days_since_sale   Int?
  velocity_score    Float?
  margin_percentage Float?
  seasonal_peak     String?
  seasonal_factor   Float                 @default(1.0)
  created_at        DateTime              @default(now())
  updated_at        DateTime              @updatedAt
  alerts            Alert[]
  competitor_prices CompetitorPrice[]
  inventory_events  InventoryEvent[]
  price_history     PriceHistory[]
  recommendations   PriceRecommendation[]
  user              User                  @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([user_id, sku_code])
  @@index([user_id, category, weekly_sales])
  @@index([user_id, brand, category])
  @@index([user_id, inventory_level, days_since_sale])
  @@index([user_id, price, weekly_sales])
  @@index([last_sold_date, user_id])
  @@index([velocity_score, user_id])
  @@map("skus")
}

model Analysis {
  id                  String                @id @default(cuid())
  upload_id           String                @unique
  file_name           String
  processed_at        DateTime
  user_id             String
  total_skus          Int
  summary             Json
  analysis_type       String                @default("standard")
  column_mapping      Json
  competitive_intel   Json?
  data_anomalies      Json?
  data_quality_score  Float?
  file_size_bytes     Int?
  ip_address          String?
  market_insights     Json?
  missing_fields      Json?
  processing_time_ms  Int?
  revenue_potential   Float                 @default(0)
  rows_processed      Int?
  rows_skipped        Int?
  seasonal_analysis   Json?
  uploaded_at         DateTime              @default(now())
  user_agent          String?
  alerts              Alert[]
  user                User                  @relation(fields: [user_id], references: [id], onDelete: Cascade)
  competitor_data     CompetitorPrice[]
  recommendations     PriceRecommendation[]
  seasonal_strategies SeasonalStrategy[]
  smart_alerts        SmartAlert[]

  @@index([user_id, processed_at(sort: Desc)])
  @@index([analysis_type, processed_at(sort: Desc)])
  @@map("analyses")
}

model PriceRecommendation {
  id                   String   @id @default(cuid())
  analysis_id          String
  sku_code             String
  user_id              String
  current_price        Float
  recommended_price    Float
  change_percentage    Float
  confidence_score     Float
  reason               String
  weekly_sales         Float
  inventory_level      Int
  revenue_impact       Float?
  risk_level           String   @default("medium")
  creative_strategies  Json?
  marketing_angles     Json?
  seasonal_timing      String?
  competitive_context  Json?
  implementation_plan  Json?
  price_elasticity     Float?
  optimal_price_range  Json?
  cannibalization_risk Float?
  created_at           DateTime @default(now())
  analysis             Analysis @relation(fields: [analysis_id], references: [upload_id], onDelete: Cascade)
  sku                  SKU      @relation(fields: [sku_code, user_id], references: [sku_code, user_id], onDelete: Cascade)

  @@index([user_id, sku_code])
  @@index([analysis_id, confidence_score(sort: Desc)])
  @@index([revenue_impact(sort: Desc)])
  @@map("price_recommendations")
}

model CompetitorPrice {
  id                   String    @id @default(cuid())
  sku_code             String
  user_id              String
  analysis_id          String?
  competitor           String
  competitor_sku       String?
  competitor_price     Float
  our_price            Float
  price_difference     Float
  price_difference_pct Float
  availability         Boolean   @default(true)
  stock_level          String?
  product_name         String?
  product_description  String?
  relevance_score      Float?
  match_confidence     Float?
  source_url           String?
  scraping_success     Boolean   @default(false)
  scraping_method      String?
  scraping_duration_ms Int?
  last_updated         DateTime  @default(now())
  next_check_due       DateTime?
  promotional          Boolean   @default(false)
  promotion_type       String?
  promotion_details    String?
  promotion_start_date DateTime?
  promotion_end_date   DateTime?
  original_price       Float?
  price_history_trend  String?
  data_anomaly_flags   Json?
  analysis             Analysis? @relation(fields: [analysis_id], references: [upload_id])
  sku                  SKU       @relation(fields: [sku_code, user_id], references: [sku_code, user_id], onDelete: Cascade)

  @@unique([sku_code, user_id, competitor, last_updated])
  @@index([user_id, sku_code, last_updated(sort: Desc)])
  @@index([competitor, availability, last_updated])
  @@index([promotional, promotion_end_date])
  @@map("competitor_prices")
}

model PriceHistory {
  id              String   @id @default(cuid())
  sku_code        String
  user_id         String
  date            DateTime
  price           Float
  cost_price      Float?
  margin          Float?
  sales_volume    Float?
  inventory_level Int?
  demand_factor   Float?
  source          String   @default("csv_upload")
  change_reason   String?
  competitor_avg  Float?
  market_position String?
  sku             SKU      @relation(fields: [sku_code, user_id], references: [sku_code, user_id], onDelete: Cascade)

  @@index([user_id, sku_code, date(sort: Desc)])
  @@index([date, user_id])
  @@map("price_history")
}

model Alert {
  id                  String    @id @default(cuid())
  user_id             String
  analysis_id         String?
  sku_code            String?
  type                String
  severity            String
  category            String?
  title               String
  message             String
  short_description   String?
  ai_recommendation   Json?
  alternative_actions Json?
  estimated_impact    Float?
  confidence_level    Float?
  urgency_score       Int       @default(5)
  revenue_at_risk     Float?
  cost_to_resolve     Float?
  time_to_resolve     Int?
  acknowledged        Boolean   @default(false)
  resolved            Boolean   @default(false)
  snoozed             Boolean   @default(false)
  assigned_to         String?
  created_at          DateTime  @default(now())
  acknowledged_at     DateTime?
  resolved_at         DateTime?
  snooze_until        DateTime?
  escalated_at        DateTime?
  resolution_notes    String?
  actual_outcome      String?
  lessons_learned     String?
  analysis            Analysis? @relation(fields: [analysis_id], references: [upload_id])
  sku                 SKU?      @relation(fields: [sku_code, user_id], references: [sku_code, user_id], onDelete: SetNull)
  user                User      @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id, severity, acknowledged])
  @@index([created_at(sort: Desc), user_id])
  @@index([urgency_score(sort: Desc), resolved])
  @@map("alerts")
}

model SmartAlert {
  id              String    @id @default(cuid())
  analysis_id     String
  type            String
  severity        String
  message         String
  recommendation  Json
  auto_generated  Boolean   @default(true)
  requires_human  Boolean   @default(false)
  escalation_path Json?
  acknowledged    Boolean   @default(false)
  resolved        Boolean   @default(false)
  auto_resolved   Boolean   @default(false)
  created_at      DateTime  @default(now())
  resolved_at     DateTime?
  analysis        Analysis  @relation(fields: [analysis_id], references: [upload_id], onDelete: Cascade)

  @@index([analysis_id, severity])
  @@map("smart_alerts")
}

model SKUHistory {
  id                  String    @id @default(cuid())
  sku_code            String
  user_id             String
  analyses            Json
  avg_weekly_sales    Float?
  sales_trend         String?
  price_trend         String?
  inventory_turnover  Float?
  profit_contribution Float?
  first_seen          DateTime  @default(now())
  last_analysis       DateTime?
  total_analyses      Int       @default(0)
  created_at          DateTime  @default(now())
  updated_at          DateTime  @updatedAt
  user                User      @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([user_id, sku_code])
  @@index([user_id, sales_trend])
  @@index([avg_weekly_sales(sort: Desc), user_id])
  @@map("sku_history")
}

model ShopifyStore {
  id                String           @id @default(cuid())
  user_id           String
  shop_domain       String
  access_token      String
  store_name        String
  store_currency    String           @default("GBP")
  store_timezone    String?
  auto_sync_enabled Boolean          @default(true)
  sync_frequency    String           @default("daily")
  last_sync         DateTime?
  last_sync_status  String?
  total_products    Int?
  synced_products   Int?
  webhook_id        String?
  webhook_verified  Boolean          @default(false)
  webhook_secret    String?
  sync_errors       Json?
  error_count       Int              @default(0)
  last_error        DateTime?
  created_at        DateTime         @default(now())
  updated_at        DateTime         @updatedAt
  inventory_events  InventoryEvent[]
  user              User             @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([user_id, shop_domain])
  @@index([auto_sync_enabled, sync_frequency])
  @@map("shopify_stores")
}

model InventoryEvent {
  id               String        @id @default(cuid())
  sku_code         String
  user_id          String
  shopify_store_id String?
  event_type       String
  quantity_change  Int
  previous_level   Int
  new_level        Int
  reason           String?
  cost_impact      Float?
  supplier_batch   String?
  event_date       DateTime      @default(now())
  recorded_at      DateTime      @default(now())
  shopify_store    ShopifyStore? @relation(fields: [shopify_store_id], references: [id])
  sku              SKU           @relation(fields: [sku_code, user_id], references: [sku_code, user_id], onDelete: Cascade)

  @@index([user_id, sku_code, event_date(sort: Desc)])
  @@index([event_type, event_date])
  @@map("inventory_events")
}

model MarketTrend {
  id              String    @id @default(cuid())
  category        String
  subcategory     String?
  region          String    @default("UK")
  trend_type      String
  direction       String
  magnitude       Float
  confidence      Float
  time_period     String
  data_source     String
  source_quality  String    @default("medium")
  market_size_gbp Float?
  growth_rate     Float?
  key_drivers     Json?
  detected_at     DateTime  @default(now())
  expires_at      DateTime?

  @@index([category, region, detected_at(sort: Desc)])
  @@index([trend_type, direction])
  @@map("market_trends")
}

model CompetitorSource {
  id                String   @id @default(cuid())
  name              String   @unique
  display_name      String
  type              String
  base_url          String
  enabled           Boolean  @default(true)
  scraping_config   Json?
  rate_limit_ms     Int      @default(2000)
  max_concurrent    Int      @default(1)
  api_endpoint      String?
  requires_auth     Boolean  @default(false)
  auth_type         String?
  success_rate      Float?
  avg_response_ms   Int?
  last_error        String?
  error_count       Int      @default(0)
  supported_regions Json?
  categories        Json?
  created_at        DateTime @default(now())
  last_updated      DateTime @default(now())

  @@map("competitor_sources")
}

model PromotionCampaign {
  id                String    @id @default(cuid())
  user_id           String
  name              String
  description       String?
  campaign_type     String
  status            String    @default("planned")
  target_skus       Json
  target_categories Json?
  discount_type     String?
  discount_value    Float?
  minimum_quantity  Int?
  start_date        DateTime
  end_date          DateTime?
  units_sold        Int       @default(0)
  revenue_generated Float     @default(0)
  cost_of_campaign  Float?
  roi_percentage    Float?
  marketing_copy    Json?
  target_audience   String?
  success_metrics   Json?
  created_at        DateTime  @default(now())
  updated_at        DateTime  @updatedAt

  @@index([user_id, status, start_date])
  @@map("promotion_campaigns")
}

model SystemMetric {
  id             String   @id @default(cuid())
  metric_name    String
  metric_value   Float
  metric_unit    String
  user_id        String?
  analysis_id    String?
  collected_at   DateTime @default(now())
  retention_days Int      @default(30)

  @@index([metric_name, collected_at(sort: Desc)])
  @@index([user_id, metric_name])
  @@map("system_metrics")
}

model SeasonalStrategy {
  id                       String    @id @default(cuid())
  analysis_id              String
  user_id                  String
  type                     String
  title                    String
  description              String
  reasoning                String
  seasonal_trigger         String
  estimated_revenue_impact Float
  urgency                  String
  implementation_timeline  String
  marketing_angle          String?
  target_customer          String?
  products_involved        Json
  execution_steps          Json
  success_metrics          Json
  risk_factors             Json
  pricing_strategy         Json
  status                   String    @default("generated")
  implemented_at           DateTime?
  completed_at             DateTime?
  actual_revenue_impact    Float?
  ai_confidence            Float?
  generated_by             String    @default("enhanced_seasonal_engine")
  created_at               DateTime  @default(now())
  updated_at               DateTime  @updatedAt
  analysis                 Analysis  @relation(fields: [analysis_id], references: [upload_id], onDelete: Cascade)
  user                     User      @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id, analysis_id])
  @@index([urgency, estimated_revenue_impact(sort: Desc)])
  @@index([type, created_at(sort: Desc)])
  @@map("seasonal_strategies")
}

// ENTERPRISE ACTION SYSTEM
// Tracks all user actions with full audit trail, rollback capability, and approval workflow

model Action {
  id                String    @id @default(cuid())
  user_id           String
  action_type       String    // price_update, reorder_stock, launch_campaign, bulk_update
  target_sku        String?   // Single SKU (null for batch actions)
  target_skus       Json?     // Multiple SKUs for batch actions

  // Action details
  action_payload    Json      // Complete action data with all parameters
  reason            String    // Human-readable reason for audit trail
  expected_impact   Float?    // Expected revenue impact (Â£)
  confidence_score  Float?    // AI confidence (0-1)

  // Execution tracking
  status            String    @default("pending") // pending, validating, executing, completed, failed, rolled_back
  initiated_by      String    // user email or 'ai_autopilot'
  initiated_at      DateTime  @default(now())
  validated_at      DateTime?
  executed_at       DateTime?
  completed_at      DateTime?

  // Approval workflow
  requires_approval Boolean   @default(false)
  approved_by       String?
  approved_at       DateTime?
  approval_notes    String?
  rejected_by       String?
  rejected_at       DateTime?
  rejection_reason  String?

  // Results tracking
  actual_impact     Float?    // Actual revenue impact measured
  success_metrics   Json?     // Detailed success metrics
  error_message     String?
  error_stack       String?

  // Rollback capability
  rollback_data     Json      // Original values for undo
  rolled_back       Boolean   @default(false)
  rolled_back_at    DateTime?
  rolled_back_by    String?
  rollback_reason   String?

  // System integration tracking
  external_refs     Json?     // { shopify_order_id, email_campaign_id, etc }
  affected_systems  String[]  // ['database', 'shopify', 'email', 'supplier']
  sync_status       Json?     // Status of external system syncs

  // Batch operations
  batch_id          String?   // Link to ActionBatch if part of bulk operation
  batch             ActionBatch? @relation(fields: [batch_id], references: [id])

  @@index([user_id, status, initiated_at(sort: Desc)])
  @@index([action_type, status])
  @@index([batch_id])
  @@index([target_sku, user_id])
  @@map("actions")
}

model ActionValidationRule {
  id              String    @id @default(cuid())
  user_id         String
  action_type     String    // price_update, reorder_stock, launch_campaign
  rule_type       String    // approval_threshold, margin_minimum, budget_limit, change_limit
  rule_config     Json      // Flexible rule configuration
  enabled         Boolean   @default(true)
  priority        Int       @default(0) // Higher priority rules evaluated first
  created_at      DateTime  @default(now())
  updated_at      DateTime  @updatedAt
  created_by      String

  @@index([user_id, action_type, enabled])
  @@map("action_validation_rules")
}

model ActionBatch {
  id              String    @id @default(cuid())
  user_id         String
  batch_name      String
  batch_type      String    // bulk_price_update, bulk_reorder, campaign_launch
  action_ids      String[]  // Array of action IDs in this batch
  total_actions   Int
  completed       Int       @default(0)
  failed          Int       @default(0)
  pending         Int
  status          String    @default("pending") // pending, executing, completed, partially_completed, failed

  // Batch execution settings
  execute_parallel Boolean   @default(false)
  max_concurrent  Int       @default(5)
  stop_on_error   Boolean   @default(false)

  // Tracking
  created_at      DateTime  @default(now())
  started_at      DateTime?
  completed_at    DateTime?
  estimated_duration Int?    // seconds
  actual_duration Int?       // seconds

  // Results
  total_expected_impact Float?
  total_actual_impact   Float?
  success_rate          Float?

  actions         Action[]

  @@index([user_id, status, created_at(sort: Desc)])
  @@map("action_batches")
}

model ActionApproval {
  id              String    @id @default(cuid())
  action_id       String    @unique
  requester_id    String    // User who initiated the action
  approver_id     String?   // User who can approve
  approval_status String    @default("pending") // pending, approved, rejected

  // Approval context
  approval_reason String
  risk_level      String    // low, medium, high, critical
  estimated_impact Float?

  // Decision tracking
  reviewed_at     DateTime?
  review_notes    String?
  auto_approved   Boolean   @default(false) // True if approved by AI/rules

  // Notifications
  notification_sent Boolean   @default(false)
  notification_sent_at DateTime?
  reminder_count  Int       @default(0)
  last_reminder   DateTime?

  created_at      DateTime  @default(now())
  expires_at      DateTime? // Auto-reject if not reviewed

  @@index([approver_id, approval_status])
  @@index([requester_id, created_at(sort: Desc)])
  @@map("action_approvals")
}
